# General GQL Types
type Query {
  burner(id: ID!): Burner!
  burners: BurnerConnection!
  habit(id: ID!): Habit!
  habits: HabitConnection!
  me: AgentProfile!
}

type Mutation {
  createBurner(burner: BurnerCreateParams): BurnerCreateResponse!
  updateBurner(burner: BurnerUpdateParams): BurnerUpdateResponse!
  deleteBurner(id: ID!): DeleteResponse!
  createHabit(habit: HabitCreateParams): HabitCreateResponse!
  updateHabit(habit: HabitUpdateParams): HabitCreateResponse!
  createProfile(profile: UserProfileCreateUpdateParams): AgentProfile!
  updateProfile(profile: UserProfileCreateUpdateParams): AgentProfile!
}

scalar DateTime

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
  endCursor: String!
}
interface Node {
  id: ID!
}

# Holochain Specific Types
type ResponsePayload {
  headerHash: String!
  entryHash: String!
}
type DeleteResponse {
  id: ID!
  deleteActionHash: String!
}

# ---- Profiles ----- #
# Profiles GQL Types

# Profiles Types
type AgentProfile {
  agentPubKey: String!
  profile: Profile!
}

type Profile {
  nickname: String!
  fields: ProfileFields
}

type ProfileFields {
  location: String
  isPublic: String
  avatar: String
}

# Profile Input/Output
input UserProfileCreateUpdateParams {
  nickname: String!
  location: String
  isPublic: String
  avatar: String
}

# ---- Burner ----- #
# Burner GQL Types
type BurnerConnection {
  edges: [BurnerEdge!]!
  pageInfo: PageInfo!
}

type BurnerEdge {
  cursor: String!
  node: Burner!
}

# Burner Types
type Burner implements Node {
  id: ID!
  name: String!
  metadata: BurnerMetaData
}

type BurnerMetaData {
  description: String!
  hashtag: String
}

# Burner Input/Outputs
input BurnerCreateParams {
  name: String!
  description: String!
  hashtag: String
}
input BurnerUpdateParams {
  id: String!
  name: String!
  description: String!
  hashtag: String
}

type BurnerCreateResponse {
  node: Burner!
}
type BurnerUpdateResponse {
  node: Burner!
  newActionHash: ID!
}

# ---- Habit ----- #
# Habit GQL Types
type HabitConnection {
  edges: [HabitEdge!]!
  pageInfo: PageInfo!
}

type HabitEdge {
  cursor: String!
  node: Habit!
}

# Habit Types
type Habit implements Node {
  id: ID!
  name: String!
  timeframe: TimeFrame!
  metadata: HabitMetaData
}

type TimeFrame {
  startTime: DateTime!
  endTime: DateTime!
}

type HabitMetaData {
  description: String!
  isAtomic: String!
  # atomicListEntryHash: String
}

# Habit Input/Outputs
input HabitCreateParams {
  name: String!
  startTime: DateTime!
  endTime: DateTime!
  description: String!
  isAtomic: String!
  # atomicListEntryHash: String
}
input HabitUpdateParams {
  id: String!
  name: String!
  startTime: DateTime!
  endTime: DateTime!
  description: String!
  isAtomic: String!
  # atomicListEntryHash: String
}

type HabitCreateResponse {
  payload: ResponsePayload!
}

#
type Todo {
  id: ID!
  description: String!
  status: Boolean!
}
